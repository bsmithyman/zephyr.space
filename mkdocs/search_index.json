{
    "docs": [
        {
            "location": "/", 
            "text": "Intro\n\n\nWelcome to the documentation and development site for \nZephyr\n: an open-source seismic full-waveform inversion toolkit. \nZephyr\n is designed to offer a convenient, easy-to-use set of tools and components that enable seismic \nFWI\n. Most importantly, \nZephyr\n is free and open-source, so you can use it for your own projects and/or contribute to its development. \nZephyr\n continues to gain features and improve daily.\n\n\n[Poster for AGU 2015][/media/\nZephyr\n-AGU2015.pdf]\n\n\nDownload\n\n\nTo download the source code for the \nZephyr\n project, please visit the \nproject page on GitHub\n.\n\n\nBranches\n\n\n\n\nmaster\n\n\nThe current main branch of development for the \nZephyr\n project.\n\n\nani_testing\n\n\nOngoing work testing anisotropic modelling code\n\n\ndistributor\n\n\nOngoing work on distributed computing schedulers for composite problems.\n\n\ndisctests\n\n\nOngoing work to write tests for the discretizations.\n\n\ninversion\n\n\nOngoing work to implement a full-featured waveform inversion workflow\n\n\noldzephyr_simpeg-integration\n\n\nDevelopment from 2014 and early 2015, which is still being laboriously merged into \nmaster\n. This includes some of the more advanced work on distributed computing, which is gradually being included in \nzephyr.middleware.distributors\n.\n\n\n\n\nDependencies\n\n\nZephyr\n is written in \nPython\n, and tested using the CPython implementation on Mac OS and Linux (at present the authors know of no reason that it wouldn't work on Windows, but this is untested).\n\n\nZephyr\n makes extensive use of \nNumPy\n and \nSciPy\n in order to support numerical operations. At present (and by design), \nzephyr.backend\n depends only on \nNumPy\n, \nSciPy\n and the \nPython\n standard library.\n\n\nThe \nfrontend\n and \nmiddleware\n layers of \nZephyr\n depend on \nIPython\n for some of the parallel computing functionality.\n\n\nThe \nfrontend\n and \nmiddleware\n layers of \nZephyr\n depend on \nSimPEG\n, which is a flexible toolkit for solving geophysical inversion problems, written in \nPython\n. Visit the \nSimPEG\n GitHub page\n to download the project, or install with pip.\n\n\nThe \nfrontend\n command-line interface depends on \nClick\n.\n\n\nZephyr\n aims to be compatible with \nMUMPS\n, and a corresponding \nPython\n-based wrapper called \npymatsolver\n, but this functionality is experimental.\n\n\nPlotting and analysis tools make use of \nmatplotlib\n.", 
            "title": "Intro"
        }, 
        {
            "location": "/#intro", 
            "text": "Welcome to the documentation and development site for  Zephyr : an open-source seismic full-waveform inversion toolkit.  Zephyr  is designed to offer a convenient, easy-to-use set of tools and components that enable seismic  FWI . Most importantly,  Zephyr  is free and open-source, so you can use it for your own projects and/or contribute to its development.  Zephyr  continues to gain features and improve daily.  [Poster for AGU 2015][/media/ Zephyr -AGU2015.pdf]", 
            "title": "Intro"
        }, 
        {
            "location": "/#download", 
            "text": "To download the source code for the  Zephyr  project, please visit the  project page on GitHub .", 
            "title": "Download"
        }, 
        {
            "location": "/#branches", 
            "text": "master  The current main branch of development for the  Zephyr  project.  ani_testing  Ongoing work testing anisotropic modelling code  distributor  Ongoing work on distributed computing schedulers for composite problems.  disctests  Ongoing work to write tests for the discretizations.  inversion  Ongoing work to implement a full-featured waveform inversion workflow  oldzephyr_simpeg-integration  Development from 2014 and early 2015, which is still being laboriously merged into  master . This includes some of the more advanced work on distributed computing, which is gradually being included in  zephyr.middleware.distributors .", 
            "title": "Branches"
        }, 
        {
            "location": "/#dependencies", 
            "text": "Zephyr  is written in  Python , and tested using the CPython implementation on Mac OS and Linux (at present the authors know of no reason that it wouldn't work on Windows, but this is untested).  Zephyr  makes extensive use of  NumPy  and  SciPy  in order to support numerical operations. At present (and by design),  zephyr.backend  depends only on  NumPy ,  SciPy  and the  Python  standard library.  The  frontend  and  middleware  layers of  Zephyr  depend on  IPython  for some of the parallel computing functionality.  The  frontend  and  middleware  layers of  Zephyr  depend on  SimPEG , which is a flexible toolkit for solving geophysical inversion problems, written in  Python . Visit the  SimPEG  GitHub page  to download the project, or install with pip.  The  frontend  command-line interface depends on  Click .  Zephyr  aims to be compatible with  MUMPS , and a corresponding  Python -based wrapper called  pymatsolver , but this functionality is experimental.  Plotting and analysis tools make use of  matplotlib .", 
            "title": "Dependencies"
        }, 
        {
            "location": "/background/", 
            "text": "Background\n\n\nExploration seismology involves applying seismic imaging and inversion techniques to build physical property models for the Earth and to delineate subsurface features. Seismic Full-Waveform Inversion (\nFWI\n) is concerned with iteratively improving on a prexisting model of the Earth, in order to better fit seismic measurements recorded in the field. Field measurements (data) are digital recordings of pressure (with hydrophones) or particle velocity (with geophones) at a number of different locations (receivers). In exploration seismology, source enegry typically comes from vibroseis and/or dynamite (onland), or airguns (offshore). One trace exists for each pair of source and receiver.\n\n\nForward modelling\n\n\nSeismic data are expressions of signals being propagated as waves, and wave equations describe (simplified) physics that model the behaviour of these waves. The constant-density 3D acoustic wave equation takes the form:\n\n\n\n\n\\left[\\nabla^2 - \\frac{1}{\\mathbf{c}\\left(x,y,z\\right)}\\frac{\\partial^2}{\\partial t^2}\\right]\\mathbf{p}\\left(x,y,z;t\\right) = \\mathbf{s}\\left(x,y,z;t\\right)\n\n\n\n\nwhere \n\\mathbf{p}\n is the pressure wavefield arising from a source distribution \n\\mathbf{s}\n in a model described by the propagation velocity \n\\mathbf{c}\n. All three quantities are scalar fields that may vary in all three spatial dimensions \n(x,y,z)\n; both \n\\mathbf{s}\n and \n\\mathbf{p}\n also vary with time \nt\n. In many cases, it may be convenient to work in the temporal \nfrequency domain\n, which requires taking the Fourier transform of the wave equation above. The resulting 3D acoustic Helmholtz equation,\n\n\n\n\n\\left[\\nabla^2 + \\frac{\\omega^2}{\\mathbf{c}^2\\left(x,y,z\\right)}\\right]\\mathbf{P}\\left(x,y,z; \\omega\\right) = \\mathbf{S}\\left(x,y,z; \\omega\\right),\n\n\n\n\ndescribes the behaviour of a \ntime-harmonic\n wavefield \n\\mathbf{P}\n as a function of the angular frequency \n\\omega = 2\\pi f\n, with temporal frequency \nf\n.\n\n\nAnalytical case\n\n\nIn the case of a constant velocity \nc\n for all locations \n(x,y,z)\n, the analytical response of this system is straightforwardly written. We may simplify by choosing to make \n\\mathbf{s}\n a point source, in which case\n\n\n\n\n\\mathbf{s} = s\\left(t\\right) \\delta\\left(x,x_\\text{s}\\right) \\delta\\left(y,y_\\text{s}\\right) \\delta\\left(z,z_\\text{s}\\right), \\text{and}\n\n\n\\mathbf{S} = \\mathscr{F}\\mathbf{s} = -S\\left(\\omega\\right) \\delta\\left(x,x_\\text{s}\\right) \\delta\\left(y,y_\\text{s}\\right) \\delta\\left(z,z_\\text{s}\\right).\n\n\n\n\nIn response to such a point source at location \n\\mathbf{x}_\\text{s} = \\left(x_\\text{s}, y_\\text{s}, z_\\text{s}\\right)\n, the wavefield \n\\mathbf{P}\n evaluated at a receiver location \n\\mathbf{x}_\\text{r}\n is described by the Green's function \nP\\left(\\mathbf{x}_\\text{s},\\mathbf{x}_\\text{r}\\right) = G\\left(\\mathbf{x}_\\text{s},\\mathbf{x}_\\text{r}\\right)S\\left(t\\right)\n, with\n\n\n\n\nG\\left(\\mathbf{x}_\\text{s},\\mathbf{x}_\\text{r}\\right) = \\frac{e^{\\pm i \\omega t \\frac{\\omega}{c}\\|\\mathbf{x}_\\text{r}-\\mathbf{x}_\\text{s}\\|}}{4\\pi \\|\\mathbf{x}_\\text{r}-\\mathbf{x}_\\text{s}\\|}\n\n\n\n\nin the case of the 3D acoustic Helmholtz equation.\n\n\nDiscrete case\n\n\nThe system of equations above can be straightforwardly discretized in the form\n\n\n\n\nA_\\mathbf{m}\\mathbf{u} = \\mathbf{q},\n\n\n\n\nwhere \nA_\\mathbf{m}\n is the system matrix representing the physics of the problem, \n\\mathbf{u}\n is the field vector (discretized \n\\mathbf{P}\n) and \n\\mathbf{q}\n is the \nRHS\n source vector (discretized \n\\mathbf{S}\n). The vector \n\\mathbf{m}\n represents discretized heterogenous model of velocity \n\\mathbf{c}\n, upon which \nA_\\mathbf{m}\n is nonlinearly dependent. The task of solving system of equations for the field vector \n\\mathbf{u}\n requires inverting the matrix \nA_\\mathbf{m}\n, such that \n\\mathbf{u} = A_\\mathbf{m}^{-1}\\mathbf{q}\n.\n\n\nData synthesis\n\n\nOnce we are equipped with a scheme to form the system of equations \nA_\\mathbf{m}\n and invert it to solve for the field vector \n\\mathbf{u}\n, we can go about the task of computing \nsynthetic data\n to simulate the response of the field experiment. We describe a data restriction operator \n\\mathcal{R}: \\mathscr{C}^3 \\to \\mathscr{C^1}\n, which maps from the complex 3D wavefield to the responses at a series of receiver locations. The action of this operator is a good conceptual model to understand how the observed data \n\\mathbf{d}_\\text{obs}\n arise from the field experiment. The equivalent matrix \nR\n extracts a 1D vector of synthetic data \n\\mathbf{d}_\\text{syn}\n from the field vector \n\\mathbf{u}\n,\n\n\n\n\n\\mathbf{d}_\\text{syn} = R\\mathbf{u} = RA_\\mathbf{m}^{-1}\\mathbf{q}.\n\n\n\n\nInversion\n\n\nIn an ideal world, the synthetic data \n\\mathbf{d}_\\text{syn}\n would match the observed data \n\\mathbf{d}_\\text{obs}\n. This perfect correspondence between the experimental results and the results of the computer model would indicate that the earth model \n\\mathbf{m}\n is correct (within the resolving ability of the experiment).\n1\n In order to quantify the errors in the model \n\\mathbf{m}\n, we define an \nobjective function\n,\n\n\n\n\n\\phi\\left(\\mathbf{m}\\right) = \\frac{1}{2} \\|\\mathbf{d}_\\text{syn} - \\mathbf{d}_\\text{obs}\\|_2^2 = \\frac{1}{2} \\|R A_\\mathbf{m}^-1 \\mathbf{q} - \\mathbf{d}_\\text{obs}\\|_2^2,\n\n\n\n\nwhich measures the error between the data arising from the field experiment (\n\\mathbf{d}_\\text{obs}\n) and the data arising from the numerical simulation (\n\\mathbf{d}_\\text{syn}\n) under the \nL_2\n-norm. Then, we define an inverse problem\n\n\n\n\n\\mathbf{m}_\\text{opt} = \\underset{\\mathbf{m}}{\\operatorname{argmin}} \\phi\\left(\\mathbf{m}\\right),\n\n\n\n\nwith the purpose of finding the optimal model \n\\mathbf{m}_\\text{opt}\n. If we were in possession of infinite computer resources, we could employ a global search over all feasible models \n\\mathbf{m}_k\n to find the best \n\\phi_{\\mathbf{m}_k} = \\phi\\left(\\mathbf{m}_k\\right)\n to fit the data\n2\n; however, in practice the solution of the forward problem \n\\mathbf{u} = A_\\mathbf{m}^{-1}\\mathbf{q}\n is quite costly, and we must employ a more efficient method for finding (something close to) \n\\mathbf{m}_\\text{opt}\n.\n\n\nLocal optimization\n\n\nRather than search over all possible \n\\mathbf{m}_k\n, we can take advantage of the fact that we often have a good estimate of \n\\mathbf{m}_\\text{opt}\n to begin with.\n3\n In this case, we might consider implementing a \nlocal optimization\n method. The simplest example is the \nsteepest descent\n or \ngradient\n algorigthm, which uses a first-order approximation to the rate of change of the data misfit with respect to each model parameter. The gradient is\n\n\n\n\n\\nabla_{\\mathbf{m}_k} \\phi\\left(\\mathbf{m}\\right) = J_{\\mathbf{m}_k}^T\\delta\\mathbf{d}^* = J_{\\mathbf{m}_k}^T \\left[\\mathbf{d}_\\text{syn} - \\mathbf{d}_\\text{obs}\\right]^*,\n\n\n\n\nwhere \nJ\n is the Jacobian matrix of partial derivatives \nJ_{\\mathbf{m}_k;i,j} = \\frac{\\partial u_i}{\\partial m_j}\n evaluated at the present model; \n\\cdot^T\n indicates transposition and \n\\cdot^*\n complex conjugation. The steepest descent algorithm is an iterative process, in which the model iterate \n\\mathbf{m}_k\n is updated in an attempt to go \"downhill\" in the space of the objective function \n\\mathbf{\\phi}\n.\n\n\n\n\n\\mathbf{m}_{k+1} = \\mathbf{m}_k - \\alpha_k \\nabla_{\\mathbf{m}_k} \\delta\\mathbf{d}^*\n\n\n\n\nFor appropriate choices of the scalar steplength \n\\alpha\n at each iteration, \n\\mathbf{m}_k\n will converge towards a model that finds a reduced value of \n\\phi\n.\n4\n Various schemes exist to improve on the steepest descent algorithm, including projection methods, conjugate gradient approaches, and higher-order methods including Newton, Gauss-Newton and quasi-Newton (l-BFGS) schemes.\n\n\nModel regularization\n\n\nIn the introduction to the \nInversion\n section, we define the inverse problem that involves finding \n\\mathbf{m}_\\text{opt}\n to minimize the misfit function \n\\phi\\left(m\\right)\n. However, we put no other \nconstraints\n on the solution. In many practical cases, we know additional information about the sorts of models that can exist, or are most feasible. Therefore, it may make sense to solve a different problem, such as\n\n\n\n\n\\mathbf{m}_\\text{opt} = \\underset{\\mathbf{m}}{\\operatorname{argmin}} \\phi\\left(\\mathbf{m}\\right) \\text{ subject to } \\mathbf{m} \\in \\mathcal{C},\n\n\n\n\nwhich additionally requires that \n\\mathbf{m}\n sits inside some (convex) constraint set \n\\mathcal{C}\n. This set could include all models that have velocities within a feasible range, or all models that are sufficiently smooth, etc. All of these criteria represent types of \nmodel regularization\n.\n\n\nIn order to find models that fit this new problem, there are various approaches that may be used:\n\n\n\n\nProjection methods\n\n\nDefine a projector \n\\mathcal{P}\n such that \n\\text{range}\\left(\\mathcal{P}\\right) \\in \\mathcal{C}\n.\n5\n Then, the projector is applied to the candidate model terates to ensure that \n\\mathbf{m}_k\n continues to satisfy \n\\mathcal{C}\n, e.g., \n\\mathbf{m}_{k+1} = \\mathcal{P} \\left[\\mathbf{m}_k - \\alpha_k \\nabla_{\\mathbf{m}_k} \\delta\\mathbf{d}^*\\right].\n\n\n\n\nPenalty methods\n\n\nRedefine the objective function \n\\phi\\left(\\mathbf{m}\\right) = \\frac{1}{2} \\|R A_\\mathbf{m}^-1 \\mathbf{q} - \\mathbf{d}_\\text{obs}\\|_2^2 + \\frac{\\lambda_R}{2}\\|R\\mathbf{m}\\|_2^2 + \\frac{\\lambda_D}{2} \\|D\\left(\\mathbf{m}-\\mathbf{m}_\\text{ref}\\right)\\|_2^2,\n with \nR\n and \nD\n chosen to penalize certain model properties. Typical choices might be for \nR\n to be a discrete representation of \n\\nabla\n (i.e., first spatial derivative) and \nD\n to be diagonal by construction.\n\n\n\n\n\n\n\n\n\n\n\n\nOf course, in practice \n\\mathbf{d}_\\text{obs} = \\mathcal{R}\\mathbf{P} + \\epsilon\n, where \n\\epsilon\n is some distribution of noise in the recordings, so a perfect match between \n\\mathbf{d}_\\text{obs}\n and \n\\mathbf{d}_\\text{syn}\n would be quite suspicious.\n\n\n\n\n\n\nIt is also important to point out that, in general, there is no single \n\\mathbf{m}_\\text{opt}\n with minimum misfit as measured under \n\\phi_\\mathbf{m}\n. Rather, there are usually an infinite number of models that can give rise to a particular misfit \n\\phi_{\\mathbf{m}_k}\n. This is an expression of nonuniqueness, and is one of the motivations for properly implementing \nModel regularization\n.\n\n\n\n\n\n\nIn practice, this estimate typically comes from from another geophysical method (e.g., traveltime inversion), in combination with \na priori\n knowledge of geology and rock physics information.\n\n\n\n\n\n\nNB: This is true as long as the initial model iterate is not a stationary point, in which case \n\\nabla_\\mathbf{m}\n is zero.\n\n\n\n\n\n\nA projector is a linear operator \n\\mathcal{P}\n that is \nidempotent\n, meaning \n\\mathcal{PP}\\mathbf{x} = \\mathcal{P}\\mathbf{x}\n.", 
            "title": "Background"
        }, 
        {
            "location": "/background/#background", 
            "text": "Exploration seismology involves applying seismic imaging and inversion techniques to build physical property models for the Earth and to delineate subsurface features. Seismic Full-Waveform Inversion ( FWI ) is concerned with iteratively improving on a prexisting model of the Earth, in order to better fit seismic measurements recorded in the field. Field measurements (data) are digital recordings of pressure (with hydrophones) or particle velocity (with geophones) at a number of different locations (receivers). In exploration seismology, source enegry typically comes from vibroseis and/or dynamite (onland), or airguns (offshore). One trace exists for each pair of source and receiver.", 
            "title": "Background"
        }, 
        {
            "location": "/background/#forward-modelling", 
            "text": "Seismic data are expressions of signals being propagated as waves, and wave equations describe (simplified) physics that model the behaviour of these waves. The constant-density 3D acoustic wave equation takes the form:   \\left[\\nabla^2 - \\frac{1}{\\mathbf{c}\\left(x,y,z\\right)}\\frac{\\partial^2}{\\partial t^2}\\right]\\mathbf{p}\\left(x,y,z;t\\right) = \\mathbf{s}\\left(x,y,z;t\\right)   where  \\mathbf{p}  is the pressure wavefield arising from a source distribution  \\mathbf{s}  in a model described by the propagation velocity  \\mathbf{c} . All three quantities are scalar fields that may vary in all three spatial dimensions  (x,y,z) ; both  \\mathbf{s}  and  \\mathbf{p}  also vary with time  t . In many cases, it may be convenient to work in the temporal  frequency domain , which requires taking the Fourier transform of the wave equation above. The resulting 3D acoustic Helmholtz equation,   \\left[\\nabla^2 + \\frac{\\omega^2}{\\mathbf{c}^2\\left(x,y,z\\right)}\\right]\\mathbf{P}\\left(x,y,z; \\omega\\right) = \\mathbf{S}\\left(x,y,z; \\omega\\right),   describes the behaviour of a  time-harmonic  wavefield  \\mathbf{P}  as a function of the angular frequency  \\omega = 2\\pi f , with temporal frequency  f .  Analytical case  In the case of a constant velocity  c  for all locations  (x,y,z) , the analytical response of this system is straightforwardly written. We may simplify by choosing to make  \\mathbf{s}  a point source, in which case   \\mathbf{s} = s\\left(t\\right) \\delta\\left(x,x_\\text{s}\\right) \\delta\\left(y,y_\\text{s}\\right) \\delta\\left(z,z_\\text{s}\\right), \\text{and}  \\mathbf{S} = \\mathscr{F}\\mathbf{s} = -S\\left(\\omega\\right) \\delta\\left(x,x_\\text{s}\\right) \\delta\\left(y,y_\\text{s}\\right) \\delta\\left(z,z_\\text{s}\\right).   In response to such a point source at location  \\mathbf{x}_\\text{s} = \\left(x_\\text{s}, y_\\text{s}, z_\\text{s}\\right) , the wavefield  \\mathbf{P}  evaluated at a receiver location  \\mathbf{x}_\\text{r}  is described by the Green's function  P\\left(\\mathbf{x}_\\text{s},\\mathbf{x}_\\text{r}\\right) = G\\left(\\mathbf{x}_\\text{s},\\mathbf{x}_\\text{r}\\right)S\\left(t\\right) , with   G\\left(\\mathbf{x}_\\text{s},\\mathbf{x}_\\text{r}\\right) = \\frac{e^{\\pm i \\omega t \\frac{\\omega}{c}\\|\\mathbf{x}_\\text{r}-\\mathbf{x}_\\text{s}\\|}}{4\\pi \\|\\mathbf{x}_\\text{r}-\\mathbf{x}_\\text{s}\\|}   in the case of the 3D acoustic Helmholtz equation.  Discrete case  The system of equations above can be straightforwardly discretized in the form   A_\\mathbf{m}\\mathbf{u} = \\mathbf{q},   where  A_\\mathbf{m}  is the system matrix representing the physics of the problem,  \\mathbf{u}  is the field vector (discretized  \\mathbf{P} ) and  \\mathbf{q}  is the  RHS  source vector (discretized  \\mathbf{S} ). The vector  \\mathbf{m}  represents discretized heterogenous model of velocity  \\mathbf{c} , upon which  A_\\mathbf{m}  is nonlinearly dependent. The task of solving system of equations for the field vector  \\mathbf{u}  requires inverting the matrix  A_\\mathbf{m} , such that  \\mathbf{u} = A_\\mathbf{m}^{-1}\\mathbf{q} .  Data synthesis  Once we are equipped with a scheme to form the system of equations  A_\\mathbf{m}  and invert it to solve for the field vector  \\mathbf{u} , we can go about the task of computing  synthetic data  to simulate the response of the field experiment. We describe a data restriction operator  \\mathcal{R}: \\mathscr{C}^3 \\to \\mathscr{C^1} , which maps from the complex 3D wavefield to the responses at a series of receiver locations. The action of this operator is a good conceptual model to understand how the observed data  \\mathbf{d}_\\text{obs}  arise from the field experiment. The equivalent matrix  R  extracts a 1D vector of synthetic data  \\mathbf{d}_\\text{syn}  from the field vector  \\mathbf{u} ,   \\mathbf{d}_\\text{syn} = R\\mathbf{u} = RA_\\mathbf{m}^{-1}\\mathbf{q}.", 
            "title": "Forward modelling"
        }, 
        {
            "location": "/background/#inversion", 
            "text": "In an ideal world, the synthetic data  \\mathbf{d}_\\text{syn}  would match the observed data  \\mathbf{d}_\\text{obs} . This perfect correspondence between the experimental results and the results of the computer model would indicate that the earth model  \\mathbf{m}  is correct (within the resolving ability of the experiment). 1  In order to quantify the errors in the model  \\mathbf{m} , we define an  objective function ,   \\phi\\left(\\mathbf{m}\\right) = \\frac{1}{2} \\|\\mathbf{d}_\\text{syn} - \\mathbf{d}_\\text{obs}\\|_2^2 = \\frac{1}{2} \\|R A_\\mathbf{m}^-1 \\mathbf{q} - \\mathbf{d}_\\text{obs}\\|_2^2,   which measures the error between the data arising from the field experiment ( \\mathbf{d}_\\text{obs} ) and the data arising from the numerical simulation ( \\mathbf{d}_\\text{syn} ) under the  L_2 -norm. Then, we define an inverse problem   \\mathbf{m}_\\text{opt} = \\underset{\\mathbf{m}}{\\operatorname{argmin}} \\phi\\left(\\mathbf{m}\\right),   with the purpose of finding the optimal model  \\mathbf{m}_\\text{opt} . If we were in possession of infinite computer resources, we could employ a global search over all feasible models  \\mathbf{m}_k  to find the best  \\phi_{\\mathbf{m}_k} = \\phi\\left(\\mathbf{m}_k\\right)  to fit the data 2 ; however, in practice the solution of the forward problem  \\mathbf{u} = A_\\mathbf{m}^{-1}\\mathbf{q}  is quite costly, and we must employ a more efficient method for finding (something close to)  \\mathbf{m}_\\text{opt} .  Local optimization  Rather than search over all possible  \\mathbf{m}_k , we can take advantage of the fact that we often have a good estimate of  \\mathbf{m}_\\text{opt}  to begin with. 3  In this case, we might consider implementing a  local optimization  method. The simplest example is the  steepest descent  or  gradient  algorigthm, which uses a first-order approximation to the rate of change of the data misfit with respect to each model parameter. The gradient is   \\nabla_{\\mathbf{m}_k} \\phi\\left(\\mathbf{m}\\right) = J_{\\mathbf{m}_k}^T\\delta\\mathbf{d}^* = J_{\\mathbf{m}_k}^T \\left[\\mathbf{d}_\\text{syn} - \\mathbf{d}_\\text{obs}\\right]^*,   where  J  is the Jacobian matrix of partial derivatives  J_{\\mathbf{m}_k;i,j} = \\frac{\\partial u_i}{\\partial m_j}  evaluated at the present model;  \\cdot^T  indicates transposition and  \\cdot^*  complex conjugation. The steepest descent algorithm is an iterative process, in which the model iterate  \\mathbf{m}_k  is updated in an attempt to go \"downhill\" in the space of the objective function  \\mathbf{\\phi} .   \\mathbf{m}_{k+1} = \\mathbf{m}_k - \\alpha_k \\nabla_{\\mathbf{m}_k} \\delta\\mathbf{d}^*   For appropriate choices of the scalar steplength  \\alpha  at each iteration,  \\mathbf{m}_k  will converge towards a model that finds a reduced value of  \\phi . 4  Various schemes exist to improve on the steepest descent algorithm, including projection methods, conjugate gradient approaches, and higher-order methods including Newton, Gauss-Newton and quasi-Newton (l-BFGS) schemes.  Model regularization  In the introduction to the  Inversion  section, we define the inverse problem that involves finding  \\mathbf{m}_\\text{opt}  to minimize the misfit function  \\phi\\left(m\\right) . However, we put no other  constraints  on the solution. In many practical cases, we know additional information about the sorts of models that can exist, or are most feasible. Therefore, it may make sense to solve a different problem, such as   \\mathbf{m}_\\text{opt} = \\underset{\\mathbf{m}}{\\operatorname{argmin}} \\phi\\left(\\mathbf{m}\\right) \\text{ subject to } \\mathbf{m} \\in \\mathcal{C},   which additionally requires that  \\mathbf{m}  sits inside some (convex) constraint set  \\mathcal{C} . This set could include all models that have velocities within a feasible range, or all models that are sufficiently smooth, etc. All of these criteria represent types of  model regularization .  In order to find models that fit this new problem, there are various approaches that may be used:   Projection methods  Define a projector  \\mathcal{P}  such that  \\text{range}\\left(\\mathcal{P}\\right) \\in \\mathcal{C} . 5  Then, the projector is applied to the candidate model terates to ensure that  \\mathbf{m}_k  continues to satisfy  \\mathcal{C} , e.g.,  \\mathbf{m}_{k+1} = \\mathcal{P} \\left[\\mathbf{m}_k - \\alpha_k \\nabla_{\\mathbf{m}_k} \\delta\\mathbf{d}^*\\right].   Penalty methods  Redefine the objective function  \\phi\\left(\\mathbf{m}\\right) = \\frac{1}{2} \\|R A_\\mathbf{m}^-1 \\mathbf{q} - \\mathbf{d}_\\text{obs}\\|_2^2 + \\frac{\\lambda_R}{2}\\|R\\mathbf{m}\\|_2^2 + \\frac{\\lambda_D}{2} \\|D\\left(\\mathbf{m}-\\mathbf{m}_\\text{ref}\\right)\\|_2^2,  with  R  and  D  chosen to penalize certain model properties. Typical choices might be for  R  to be a discrete representation of  \\nabla  (i.e., first spatial derivative) and  D  to be diagonal by construction.       Of course, in practice  \\mathbf{d}_\\text{obs} = \\mathcal{R}\\mathbf{P} + \\epsilon , where  \\epsilon  is some distribution of noise in the recordings, so a perfect match between  \\mathbf{d}_\\text{obs}  and  \\mathbf{d}_\\text{syn}  would be quite suspicious.    It is also important to point out that, in general, there is no single  \\mathbf{m}_\\text{opt}  with minimum misfit as measured under  \\phi_\\mathbf{m} . Rather, there are usually an infinite number of models that can give rise to a particular misfit  \\phi_{\\mathbf{m}_k} . This is an expression of nonuniqueness, and is one of the motivations for properly implementing  Model regularization .    In practice, this estimate typically comes from from another geophysical method (e.g., traveltime inversion), in combination with  a priori  knowledge of geology and rock physics information.    NB: This is true as long as the initial model iterate is not a stationary point, in which case  \\nabla_\\mathbf{m}  is zero.    A projector is a linear operator  \\mathcal{P}  that is  idempotent , meaning  \\mathcal{PP}\\mathbf{x} = \\mathcal{P}\\mathbf{x} .", 
            "title": "Inversion"
        }, 
        {
            "location": "/design/", 
            "text": "Design\n\n\nZephyr is written to make heavy use of object-oriented programming techniques, including \nclass multiple inheritance\n. The majority of programming constructs in the Zephyr implementation are subclasses of \nAttributeMapper\n, which automatically handles configuring new objects based on a global \nsystemConfig\n dictionary (i.e., a key/value store).\n1\n\n\nThe interrelation between different packages (i.e., sub-modules) and object classes in Zephyr is easiest to understand visually. The following graphs were designed using \npylint\n's \npyreverse\n command, and can be recreated by running\n\n\nmake graphs\n\n\n\nin the base directory of Zephyr's source code.\n\n\nSubmodule structure and design goals\n\n\nThis graph shows the linkages between Zephyr's submodules, including which submodules depend on others. It is important to note that \nzephyr.backend\n is intended to be minimally dependent on non-standard external packages, to enable solvers to be \neasily embedded in existing code\n. The \nzephyr.middleware\n layer is dependent on features in SimPEG and other libraries to enable waveform inversion.\n\n\n\nClick to expand\n\n\nThe \nzephyr.frontend\n layer is designed to encompass user-facing features, including the \ncommand-line interface\n.\n\n\nClass inheritance graph\n\n\nThis graph shows the interrelation between the object classes in Zephyr. The dependencies for \nzephyr.backend\n are largely internal, whereas several features of \nzephyr.middleware\n depend on SimPEG.\n\n\n\nClick to expand\n\n\nObject hierarchy and \nAttributeMapper\n\n\nAn \nAttributeMapper\n subclass defines a dictionary \ninitMap\n, which\nincludes keys for mappable inputs expected from the systemConfig\nparameter. The class definition takes the form:\n\n\nclass BaseModelDependent(AttributeMapper):\n    '''\n    AttributeMapper subclass that implements model-dependent properties,\n    such as grid coordinates and free-surface conditions.\n    '''\n\n    initMap = {\n    #   Argument        Required    Rename as ...   Store as type\n        'nx':           (True,      None,           np.int64),\n        'ny':           (False,     None,           np.int64),\n        'nz':           (True,      None,           np.int64),\n        'xorig':        (False,     '_xorig',       np.float64),\n        'yorig':        (False,     '_xorig',       np.float64),\n        'zorig':        (False,     '_zorig',       np.float64),\n        'dx':           (False,     '_dx',          np.float64),\n        'dy':           (False,     '_dx',          np.float64),\n        'dz':           (False,     '_dz',          np.float64),\n        'freeSurf':     (False,     '_freeSurf',    tuple),\n    }\n    ...\n\n\n\n\n\n\n\nEach value in the dictionary is a tuple, which is interpreted by\nthe \nAttributeMapper\n1\n to determine how to process the\nvalue corresponding to the same key in \nsystemConfig\n.\n\n\n\n\n\n\nAn exception will be raised if the first element in the tuple\nis set to true, but the corresponding key does not exist in the\nsystemConfig parameter.\n\n\n\n\n\n\nIf the second element in the tuple is set to \nNone\n, the key will be\ndefined in the subclass's attribute dictionary as it stands, whereas\nif the second element is a string then that overrides the key.\n\n\n\n\n\n\nIf the third element in the tuple is set to \nNone\n, the input argument\nwill be set in the subclass dictionary unmodified; however, if the\nthird element is a callable then it will be applied to the element\n(e.g., to allow copying and/or typecasting of inputs).\n\n\n\n\n\n\nNB: Complex \nnumpy\n arguments are handled specially: the real part of\nthe value is kept and the imaginary part is discarded when they are\ntypecast to a float.\n\n\n\n\n\n\n\n\n\n\nIn fact, most of the assembly of objects is handled by \nzephyr.backend.meta.AMMetaClass\n, which is the \nmetaclass\n for \nAttributeMapper\n and its descendants. All of this happens before the call to \nAttributeMapper.__init__\n. This enables the \ninitMap\n class attribute to be merged automatically and inherit keys from the subclass's bases.", 
            "title": "Overview"
        }, 
        {
            "location": "/design/#design", 
            "text": "Zephyr is written to make heavy use of object-oriented programming techniques, including  class multiple inheritance . The majority of programming constructs in the Zephyr implementation are subclasses of  AttributeMapper , which automatically handles configuring new objects based on a global  systemConfig  dictionary (i.e., a key/value store). 1  The interrelation between different packages (i.e., sub-modules) and object classes in Zephyr is easiest to understand visually. The following graphs were designed using  pylint 's  pyreverse  command, and can be recreated by running  make graphs  in the base directory of Zephyr's source code.", 
            "title": "Design"
        }, 
        {
            "location": "/design/#submodule-structure-and-design-goals", 
            "text": "This graph shows the linkages between Zephyr's submodules, including which submodules depend on others. It is important to note that  zephyr.backend  is intended to be minimally dependent on non-standard external packages, to enable solvers to be  easily embedded in existing code . The  zephyr.middleware  layer is dependent on features in SimPEG and other libraries to enable waveform inversion.  \nClick to expand  The  zephyr.frontend  layer is designed to encompass user-facing features, including the  command-line interface .", 
            "title": "Submodule structure and design goals"
        }, 
        {
            "location": "/design/#class-inheritance-graph", 
            "text": "This graph shows the interrelation between the object classes in Zephyr. The dependencies for  zephyr.backend  are largely internal, whereas several features of  zephyr.middleware  depend on SimPEG.  \nClick to expand", 
            "title": "Class inheritance graph"
        }, 
        {
            "location": "/design/#object-hierarchy-and-attributemapper", 
            "text": "An  AttributeMapper  subclass defines a dictionary  initMap , which\nincludes keys for mappable inputs expected from the systemConfig\nparameter. The class definition takes the form:  class BaseModelDependent(AttributeMapper):\n    '''\n    AttributeMapper subclass that implements model-dependent properties,\n    such as grid coordinates and free-surface conditions.\n    '''\n\n    initMap = {\n    #   Argument        Required    Rename as ...   Store as type\n        'nx':           (True,      None,           np.int64),\n        'ny':           (False,     None,           np.int64),\n        'nz':           (True,      None,           np.int64),\n        'xorig':        (False,     '_xorig',       np.float64),\n        'yorig':        (False,     '_xorig',       np.float64),\n        'zorig':        (False,     '_zorig',       np.float64),\n        'dx':           (False,     '_dx',          np.float64),\n        'dy':           (False,     '_dx',          np.float64),\n        'dz':           (False,     '_dz',          np.float64),\n        'freeSurf':     (False,     '_freeSurf',    tuple),\n    }\n    ...    Each value in the dictionary is a tuple, which is interpreted by\nthe  AttributeMapper 1  to determine how to process the\nvalue corresponding to the same key in  systemConfig .    An exception will be raised if the first element in the tuple\nis set to true, but the corresponding key does not exist in the\nsystemConfig parameter.    If the second element in the tuple is set to  None , the key will be\ndefined in the subclass's attribute dictionary as it stands, whereas\nif the second element is a string then that overrides the key.    If the third element in the tuple is set to  None , the input argument\nwill be set in the subclass dictionary unmodified; however, if the\nthird element is a callable then it will be applied to the element\n(e.g., to allow copying and/or typecasting of inputs).    NB: Complex  numpy  arguments are handled specially: the real part of\nthe value is kept and the imaginary part is discarded when they are\ntypecast to a float.      In fact, most of the assembly of objects is handled by  zephyr.backend.meta.AMMetaClass , which is the  metaclass  for  AttributeMapper  and its descendants. All of this happens before the call to  AttributeMapper.__init__ . This enables the  initMap  class attribute to be merged automatically and inherit keys from the subclass's bases.", 
            "title": "Object hierarchy and AttributeMapper"
        }, 
        {
            "location": "/frontend/", 
            "text": "Frontend / User Interface\n\n\nThe Zephyr project aims to fulfill two main goals:\n\n\n\n\nTo support interactive research computing and designing new algorithms, with a focus on seismic waveform inversion, and\n\n\nto provide a flexible interface to run waveform inversion computations on parallel computing environments.\n\n\n\n\nFurthermore, Zephyr makes use of distributed computing tools from IPython, which are leveraged in both operating modes. IPython (and Jupyter) combine to produce the notebook interface that is quickly becoming the standard for interactive scientific computing in Python and other interpreted languages.\n\n\nCommand-line interface (\nzephyr.frontend.CLI\n)\n\n\nNB: Work in progress\n\n\nIn order to provide a lightweight, non-interactive batch-mode for production and cluster computations, we have implemented a command-line based frontend to Zephyr. This command-line interface presents several sub commands that control the different functions.\n\n\nUsage: zephyr [OPTIONS] COMMAND [ARGS]...\n\n  A command-line interface for Zephyr\n\nOptions:\n  --version  Show the version and exit.\n  --help     Show this message and exit.\n\nCommands:\n  clean    Clean up project results / outputs\n  init     Set up a new modelling or inversion project\n  inspect  Print information about an existing project\n  invert   Run an inversion project\n  migrate  Run a migration\n  model    Run a forward model\n  pack     Collect configuration into an HDF5 datafile\n  unpack   Extract configuration from an HDF5 datafile\n\n\n\nzephyr clean\n\n\nClean up project results / outputs\n\n\nThe purpose of the \nclean\n command is to remove output files from the working directory and prepare to restart / relaunch the one of the commands \ninvert\n, \nmigrate\n or \nmodel\n. The \nclean\n command will always prompt with a list of files to delete.\n\n\nzephyr init\n\n\nSet up a new modelling or inversion project\n\n\nThe purpose of the \ninit\n command is to generate the required files to run \ninvert\n, \nmigrate\n or \nmodel\n. These files and configurations may then be modified to configure the inversion.\n\n\nzephyr inspect\n\n\nPrint information about an existing project", 
            "title": "Frontend / UI"
        }, 
        {
            "location": "/frontend/#frontend-user-interface", 
            "text": "The Zephyr project aims to fulfill two main goals:   To support interactive research computing and designing new algorithms, with a focus on seismic waveform inversion, and  to provide a flexible interface to run waveform inversion computations on parallel computing environments.   Furthermore, Zephyr makes use of distributed computing tools from IPython, which are leveraged in both operating modes. IPython (and Jupyter) combine to produce the notebook interface that is quickly becoming the standard for interactive scientific computing in Python and other interpreted languages.", 
            "title": "Frontend / User Interface"
        }, 
        {
            "location": "/frontend/#command-line-interface-zephyrfrontendcli", 
            "text": "NB: Work in progress  In order to provide a lightweight, non-interactive batch-mode for production and cluster computations, we have implemented a command-line based frontend to Zephyr. This command-line interface presents several sub commands that control the different functions.  Usage: zephyr [OPTIONS] COMMAND [ARGS]...\n\n  A command-line interface for Zephyr\n\nOptions:\n  --version  Show the version and exit.\n  --help     Show this message and exit.\n\nCommands:\n  clean    Clean up project results / outputs\n  init     Set up a new modelling or inversion project\n  inspect  Print information about an existing project\n  invert   Run an inversion project\n  migrate  Run a migration\n  model    Run a forward model\n  pack     Collect configuration into an HDF5 datafile\n  unpack   Extract configuration from an HDF5 datafile  zephyr clean  Clean up project results / outputs  The purpose of the  clean  command is to remove output files from the working directory and prepare to restart / relaunch the one of the commands  invert ,  migrate  or  model . The  clean  command will always prompt with a list of files to delete.  zephyr init  Set up a new modelling or inversion project  The purpose of the  init  command is to generate the required files to run  invert ,  migrate  or  model . These files and configurations may then be modified to configure the inversion.  zephyr inspect  Print information about an existing project", 
            "title": "Command-line interface (zephyr.frontend.CLI)"
        }, 
        {
            "location": "/embedding/", 
            "text": "Embedding\n\n\nOne of the design goals for Zephyr is to ensure that the forward-modelling architecture (viz., \nzephyr.backend\n) may be straightforwardly embedded in other programs. As such, an effort has been made to limit the dependencies for the backend infrastructure that handles simulating wave equations. In particular, Zephyr has been designed to interface with a new version of FULLWV, a well-known academic seismic full-waveform inversion package by Prof. R. Gerhard Pratt et al.\n\n\nFULLWV integration", 
            "title": "Embedding"
        }, 
        {
            "location": "/embedding/#embedding", 
            "text": "One of the design goals for Zephyr is to ensure that the forward-modelling architecture (viz.,  zephyr.backend ) may be straightforwardly embedded in other programs. As such, an effort has been made to limit the dependencies for the backend infrastructure that handles simulating wave equations. In particular, Zephyr has been designed to interface with a new version of FULLWV, a well-known academic seismic full-waveform inversion package by Prof. R. Gerhard Pratt et al.", 
            "title": "Embedding"
        }, 
        {
            "location": "/embedding/#fullwv-integration", 
            "text": "", 
            "title": "FULLWV integration"
        }, 
        {
            "location": "/about/", 
            "text": "About\n\n\nZephyr\n is the product of research at the \nUniversity of Western Ontario\n, with funding through a \nNSERC\n Postdoctoral Fellowship to Brendan Smithyman and an \nNSERC\n Discovery Grant to R. Gerhard Pratt. The implementation of anisotropic acoustic wave equation (\nzephyr.backend.Eurus\n) is the work of Shaun Hadden, an MSc candidate at \nUWO\n.\n\n\nIn addition, \nZephyr\n interoperates tightly with \nSimPEG\n, a flexible tool for designing and executing geophysical inversion problems. In turn, both \nZephyr\n and \nSimPEG\n are dependent on the \nPython\n programming language, \nNumPy\n, \nSciPy\n and \nJupyter\n/\nIPython\n. Please check out and support these open-source projects.", 
            "title": "About"
        }, 
        {
            "location": "/about/#about", 
            "text": "Zephyr  is the product of research at the  University of Western Ontario , with funding through a  NSERC  Postdoctoral Fellowship to Brendan Smithyman and an  NSERC  Discovery Grant to R. Gerhard Pratt. The implementation of anisotropic acoustic wave equation ( zephyr.backend.Eurus ) is the work of Shaun Hadden, an MSc candidate at  UWO .  In addition,  Zephyr  interoperates tightly with  SimPEG , a flexible tool for designing and executing geophysical inversion problems. In turn, both  Zephyr  and  SimPEG  are dependent on the  Python  programming language,  NumPy ,  SciPy  and  Jupyter / IPython . Please check out and support these open-source projects.", 
            "title": "About"
        }, 
        {
            "location": "/autodocs/", 
            "text": "window.location.href = \"/api/zephyr.html\"", 
            "title": "Autodocs"
        }
    ]
}