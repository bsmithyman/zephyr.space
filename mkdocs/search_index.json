{
    "docs": [
        {
            "location": "/", 
            "text": "Intro\n\n\nWelcome to the documentation and development site for \nZephyr\n: an open-source seismic full-waveform inversion toolkit. \nZephyr\n is designed to offer a convenient, easy-to-use set of tools and components that enable seismic \nFWI\n. Most importantly, \nZephyr\n is free and open-source, so you can use it for your own projects and/or contribute to its development. \nZephyr\n continues to gain features and improve daily.", 
            "title": "Intro"
        }, 
        {
            "location": "/#intro", 
            "text": "Welcome to the documentation and development site for  Zephyr : an open-source seismic full-waveform inversion toolkit.  Zephyr  is designed to offer a convenient, easy-to-use set of tools and components that enable seismic  FWI . Most importantly,  Zephyr  is free and open-source, so you can use it for your own projects and/or contribute to its development.  Zephyr  continues to gain features and improve daily.", 
            "title": "Intro"
        }, 
        {
            "location": "/background/", 
            "text": "Background\n\n\nExploration seismology involves applying seismic imaging and inversion techniques to build physical property models for the Earth and to delineate subsurface features. Seismic Full-Waveform Inversion (\nFWI\n) is concerned with iteratively improving on a prexisting model of the Earth, in order to better fit seismic measurements recorded in the field. Field measurements (data) are digital recordings of pressure (with hydrophones) or particle velocity (with geophones) at a number of different locations (receivers). In exploration seismology, source enegry typically comes from vibroseis and/or dynamite (onland), or airguns (offshore). One trace exists for each pair of source and receiver.\n\n\nForward modelling\n\n\nSeismic data are expressions of signals being propagated as waves, and wave equations describe (simplified) physics that model the behaviour of these waves. The constant-density 3D acoustic wave equation takes the form:\n\n\n\n\n\\left[\\nabla^2 - \\frac{1}{\\mathbf{c}\\left(x,y,z\\right)}\\frac{\\partial^2}{\\partial t^2}\\right]\\mathbf{p}\\left(x,y,z;t\\right) = \\mathbf{s}\\left(x,y,z;t\\right)\n\n\n\n\nwhere \n\\mathbf{p}\n is the pressure wavefield arising from a source distribution \n\\mathbf{s}\n in a model described by the propagation velocity \n\\mathbf{c}\n. All three quantities are scalar fields that may vary in all three spatial dimensions \n(x,y,z)\n; both \n\\mathbf{s}\n and \n\\mathbf{p}\n also vary with time \nt\n. In many cases, it may be convenient to work in the temporal \nfrequency domain\n, which requires taking the Fourier transform of the wave equation above. The resulting 3D acoustic Helmholtz equation,\n\n\n\n\n\\left[\\nabla^2 + \\frac{\\omega^2}{\\mathbf{c}^2\\left(x,y,z\\right)}\\right]\\mathbf{P}\\left(x,y,z; \\omega\\right) = \\mathbf{S}\\left(x,y,z; \\omega\\right),\n\n\n\n\ndescribes the behaviour of a \ntime-harmonic\n wavefield \n\\mathbf{P}\n as a function of the angular frequency \n\\omega = 2\\pi f\n, with temporal frequency \nf\n.\n\n\nAnalytical case\n\n\nIn the case of a constant velocity \nc\n for all locations \n(x,y,z)\n, the analytical response of this system is straightforwardly written. We may simplify by choosing to make \n\\mathbf{s}\n a point source, in which case\n\n\n\n\n\\mathbf{s} = s\\left(t\\right) \\delta\\left(x,x_\\text{s}\\right) \\delta\\left(y,y_\\text{s}\\right) \\delta\\left(z,z_\\text{s}\\right), \\text{and}\n\n\n\\mathbf{S} = \\mathscr{F}\\mathbf{s} = -S\\left(\\omega\\right) \\delta\\left(x,x_\\text{s}\\right) \\delta\\left(y,y_\\text{s}\\right) \\delta\\left(z,z_\\text{s}\\right).\n\n\n\n\nIn response to such a point source at location \n\\mathbf{x}_\\text{s} = \\left(x_\\text{s}, y_\\text{s}, z_\\text{s}\\right)\n, the wavefield \n\\mathbf{P}\n evaluated at a receiver location \n\\mathbf{x}_\\text{r}\n is described by the Green's function \nP\\left(\\mathbf{x}_\\text{s},\\mathbf{x}_\\text{r}\\right) = G\\left(\\mathbf{x}_\\text{s},\\mathbf{x}_\\text{r}\\right)S\\left(t\\right)\n, with\n\n\n\n\nG\\left(\\mathbf{x}_\\text{s},\\mathbf{x}_\\text{r}\\right) = \\frac{e^{\\pm i \\omega t \\frac{\\omega}{c}\\|\\mathbf{x}_\\text{r}-\\mathbf{x}_\\text{s}\\|}}{4\\pi \\|\\mathbf{x}_\\text{r}-\\mathbf{x}_\\text{s}\\|}\n\n\n\n\nin the case of the 3D acoustic Helmholtz equation.\n\n\nDiscrete case\n\n\nThe system of equations above can be straightforwardly discretized in the form\n\n\n\n\nA_\\mathbf{m}\\mathbf{u} = \\mathbf{q},\n\n\n\n\nwhere \nA_\\mathbf{m}\n is the system matrix representing the physics of the problem, \n\\mathbf{u}\n is the field vector (discretized \n\\mathbf{P}\n) and \n\\mathbf{q}\n is the \nRHS\n source vector (discretized \n\\mathbf{S}\n). The vector \n\\mathbf{m}\n represents discretized heterogenous model of velocity \n\\mathbf{c}\n, upon which \nA_\\mathbf{m}\n is nonlinearly dependent. The task of solving system of equations for the field vector \n\\mathbf{u}\n requires inverting the matrix \nA_\\mathbf{m}\n, such that \n\\mathbf{u} = A_\\mathbf{m}^{-1}\\mathbf{q}\n.\n\n\nData synthesis\n\n\nOnce we are equipped with a scheme to form the system of equations \nA_\\mathbf{m}\n and invert it to solve for the field vector \n\\mathbf{u}\n, we can go about the task of computing \nsynthetic data\n to simulate the response of the field experiment. We describe a data restriction operator \n\\mathcal{R}: \\mathscr{C}^3 \\to \\mathscr{C^1}\n, which maps from the complex 3D wavefield to the responses at a series of receiver locations. The action of this operator is a good conceptual model to understand how the observed data \n\\mathbf{d}_\\text{obs}\n arise from the field experiment. The equivalent matrix \nR\n extracts a 1D vector of synthetic data \n\\mathbf{d}_\\text{syn}\n from the field vector \n\\mathbf{u}\n,\n\n\n\n\n\\mathbf{d}_\\text{syn} = R\\mathbf{u} = RA_\\mathbf{m}^{-1}\\mathbf{q}.\n\n\n\n\nInversion\n\n\nIn an ideal world, the synthetic data \n\\mathbf{d}_\\text{syn}\n would match the observed data \n\\mathbf{d}_\\text{obs}\n. This perfect correspondence between the experimental results and the results of the computer model would indicate that the earth model \n\\mathbf{m}\n is correct (within the resolving ability of the experiment).\n1\n In order to quantify the errors in the model \n\\mathbf{m}\n, we define an \nobjective function\n,\n\n\n\n\n\\phi\\left(\\mathbf{m}\\right) = \\frac{1}{2} \\|\\mathbf{d}_\\text{syn} - \\mathbf{d}_\\text{obs}\\|_2^2 = \\frac{1}{2} \\|R A_\\mathbf{m}^-1 \\mathbf{q} - \\mathbf{d}_\\text{obs}\\|_2^2,\n\n\n\n\nwhich measures the error between the data arising from the field experiment (\n\\mathbf{d}_\\text{obs}\n) and the data arising from the numerical simulation (\n\\mathbf{d}_\\text{syn}\n) under the \nL_2\n-norm. Then, we define an inverse problem\n\n\n\n\n\\mathbf{m}_\\text{opt} = \\underset{\\mathbf{m}}{\\operatorname{argmin}} \\phi\\left(\\mathbf{m}\\right),\n\n\n\n\nwith the purpose of finding the optimal model \n\\mathbf{m}_\\text{opt}\n. If we were in possession of infinite computer resources, we could employ a global search over all feasible models \n\\mathbf{m}_k\n to find the best \n\\phi_{\\mathbf{m}_k} = \\phi\\left(\\mathbf{m}_k\\right)\n to fit the data\n2\n; however, in practice the solution of the forward problem \n\\mathbf{u} = A_\\mathbf{m}^{-1}\\mathbf{q}\n is quite costly, and we must employ a more efficient method for finding (something close to) \n\\mathbf{m}_\\text{opt}\n.\n\n\nLocal optimization\n\n\nRather than search over all possible \n\\mathbf{m}_k\n, we can take advantage of the fact that we often have a good estimate of \n\\mathbf{m}_\\text{opt}\n to begin with.\n3\n In this case, we might consider implementing a \nlocal optimization\n method. The simplest example is the \nsteepest descent\n or \ngradient\n algorigthm, which uses a first-order approximation to the rate of change of the data misfit with respect to each model parameter. The gradient is\n\n\n\n\n\\nabla_{\\mathbf{m}_k} \\phi\\left(\\mathbf{m}\\right) = J_{\\mathbf{m}_k}^T\\delta\\mathbf{d}^* = J_{\\mathbf{m}_k}^T \\left[\\mathbf{d}_\\text{syn} - \\mathbf{d}_\\text{obs}\\right]^*,\n\n\n\n\nwhere \nJ\n is the Jacobian matrix of partial derivatives \nJ_{\\mathbf{m}_k;i,j} = \\frac{\\partial u_i}{\\partial m_j}\n evaluated at the present model; \n\\cdot^T\n indicates transposition and \n\\cdot^*\n complex conjugation. The steepest descent algorithm is an iterative process, in which the model iterate \n\\mathbf{m}_k\n is updated in an attempt to go \"downhill\" in the space of the objective function \n\\mathbf{\\phi}\n.\n\n\n\n\n\\mathbf{m}_{k+1} = \\mathbf{m}_k - \\alpha_k \\nabla_{\\mathbf{m}_k} \\delta\\mathbf{d}^*\n\n\n\n\nFor appropriate choices of the scalar steplength \n\\alpha\n at each iteration, \n\\mathbf{m}_k\n will converge towards a model that finds a reduced value of \n\\phi\n.\n4\n Various schemes exist to improve on the steepest descent algorithm, including projection methods, conjugate gradient approaches, and higher-order methods including Newton, Gauss-Newton and quasi-Newton (l-BFGS) schemes.\n\n\nModel regularization\n\n\nIn the introduction to the \nInversion\n section, we define the inverse problem that involves finding \n\\mathbf{m}_\\text{opt}\n to minimize the misfit function \n\\phi\\left(m\\right)\n. However, we put no other \nconstraints\n on the solution. In many practical cases, we know additional information about the sorts of models that can exist, or are most feasible. Therefore, it may make sense to solve a different problem, such as\n\n\n\n\n\\mathbf{m}_\\text{opt} = \\underset{\\mathbf{m}}{\\operatorname{argmin}} \\phi\\left(\\mathbf{m}\\right) \\text{ subject to } \\mathbf{m} \\in \\mathcal{C},\n\n\n\n\nwhich additionally requires that \n\\mathbf{m}\n sits inside some (convex) constraint set \n\\mathcal{C}\n. This set could include all models that have velocities within a feasible range, or all models that are sufficiently smooth, etc. All of these criteria represent types of \nmodel regularization\n.\n\n\nIn order to find models that fit this new problem, there are various approaches that may be used:\n\n\n\n\nProjection methods\n\n\nDefine a projector \n\\mathcal{P}\n such that \n\\text{range}\\left(\\mathcal{P}\\right) \\in \\mathcal{C}\n.\n5\n Then, the projector is applied to the candidate model terates to ensure that \n\\mathbf{m}_k\n continues to satisfy \n\\mathcal{C}\n, e.g., \n\\mathbf{m}_{k+1} = \\mathcal{P} \\left[\\mathbf{m}_k - \\alpha_k \\nabla_{\\mathbf{m}_k} \\delta\\mathbf{d}^*\\right].\n\n\n\n\nPenalty methods\n\n\nRedefine the objective function \n\\phi\\left(\\mathbf{m}\\right) = \\frac{1}{2} \\|R A_\\mathbf{m}^-1 \\mathbf{q} - \\mathbf{d}_\\text{obs}\\|_2^2 + \\frac{\\lambda_R}{2}\\|R\\mathbf{m}\\|_2^2 + \\frac{\\lambda_D}{2} \\|D\\left(\\mathbf{m}-\\mathbf{m}_\\text{ref}\\right)\\|_2^2,\n with \nR\n and \nD\n chosen to penalize certain model properties. Typical choices might be for \nR\n to be a discrete representation of \n\\nabla\n (i.e., first spatial derivative) and \nD\n to be diagonal by construction.\n\n\n\n\n\n\n\n\n\n\n\n\nOf course, in practice \n\\mathbf{d}_\\text{obs} = \\mathcal{R}\\mathbf{P} + \\epsilon\n, where \n\\epsilon\n is some distribution of noise in the recordings, so a perfect match between \n\\mathbf{d}_\\text{obs}\n and \n\\mathbf{d}_\\text{syn}\n would be quite suspicious.\n\n\n\n\n\n\nIt is also important to point out that, in general, there is no single \n\\mathbf{m}_\\text{opt}\n with minimum misfit as measured under \n\\phi_\\mathbf{m}\n. Rather, there are usually an infinite number of models that can give rise to a particular misfit \n\\phi_{\\mathbf{m}_k}\n. This is an expression of nonuniqueness, and is one of the motivations for properly implementing \nModel regularization\n.\n\n\n\n\n\n\nIn practice, this estimate typically comes from from another geophysical method (e.g., traveltime inversion), in combination with \na priori\n knowledge of geology and rock physics information.\n\n\n\n\n\n\nNB: This is true as long as the initial model iterate is not a stationary point, in which case \n\\nabla_\\mathbf{m}\n is zero.\n\n\n\n\n\n\nA projector is a linear operator \n\\mathcal{P}\n that is \nidempotent\n, meaning \n\\mathcal{PP}\\mathbf{x} = \\mathcal{P}\\mathbf{x}\n.", 
            "title": "Background"
        }, 
        {
            "location": "/background/#background", 
            "text": "Exploration seismology involves applying seismic imaging and inversion techniques to build physical property models for the Earth and to delineate subsurface features. Seismic Full-Waveform Inversion ( FWI ) is concerned with iteratively improving on a prexisting model of the Earth, in order to better fit seismic measurements recorded in the field. Field measurements (data) are digital recordings of pressure (with hydrophones) or particle velocity (with geophones) at a number of different locations (receivers). In exploration seismology, source enegry typically comes from vibroseis and/or dynamite (onland), or airguns (offshore). One trace exists for each pair of source and receiver.", 
            "title": "Background"
        }, 
        {
            "location": "/background/#forward-modelling", 
            "text": "Seismic data are expressions of signals being propagated as waves, and wave equations describe (simplified) physics that model the behaviour of these waves. The constant-density 3D acoustic wave equation takes the form:   \\left[\\nabla^2 - \\frac{1}{\\mathbf{c}\\left(x,y,z\\right)}\\frac{\\partial^2}{\\partial t^2}\\right]\\mathbf{p}\\left(x,y,z;t\\right) = \\mathbf{s}\\left(x,y,z;t\\right)   where  \\mathbf{p}  is the pressure wavefield arising from a source distribution  \\mathbf{s}  in a model described by the propagation velocity  \\mathbf{c} . All three quantities are scalar fields that may vary in all three spatial dimensions  (x,y,z) ; both  \\mathbf{s}  and  \\mathbf{p}  also vary with time  t . In many cases, it may be convenient to work in the temporal  frequency domain , which requires taking the Fourier transform of the wave equation above. The resulting 3D acoustic Helmholtz equation,   \\left[\\nabla^2 + \\frac{\\omega^2}{\\mathbf{c}^2\\left(x,y,z\\right)}\\right]\\mathbf{P}\\left(x,y,z; \\omega\\right) = \\mathbf{S}\\left(x,y,z; \\omega\\right),   describes the behaviour of a  time-harmonic  wavefield  \\mathbf{P}  as a function of the angular frequency  \\omega = 2\\pi f , with temporal frequency  f .  Analytical case  In the case of a constant velocity  c  for all locations  (x,y,z) , the analytical response of this system is straightforwardly written. We may simplify by choosing to make  \\mathbf{s}  a point source, in which case   \\mathbf{s} = s\\left(t\\right) \\delta\\left(x,x_\\text{s}\\right) \\delta\\left(y,y_\\text{s}\\right) \\delta\\left(z,z_\\text{s}\\right), \\text{and}  \\mathbf{S} = \\mathscr{F}\\mathbf{s} = -S\\left(\\omega\\right) \\delta\\left(x,x_\\text{s}\\right) \\delta\\left(y,y_\\text{s}\\right) \\delta\\left(z,z_\\text{s}\\right).   In response to such a point source at location  \\mathbf{x}_\\text{s} = \\left(x_\\text{s}, y_\\text{s}, z_\\text{s}\\right) , the wavefield  \\mathbf{P}  evaluated at a receiver location  \\mathbf{x}_\\text{r}  is described by the Green's function  P\\left(\\mathbf{x}_\\text{s},\\mathbf{x}_\\text{r}\\right) = G\\left(\\mathbf{x}_\\text{s},\\mathbf{x}_\\text{r}\\right)S\\left(t\\right) , with   G\\left(\\mathbf{x}_\\text{s},\\mathbf{x}_\\text{r}\\right) = \\frac{e^{\\pm i \\omega t \\frac{\\omega}{c}\\|\\mathbf{x}_\\text{r}-\\mathbf{x}_\\text{s}\\|}}{4\\pi \\|\\mathbf{x}_\\text{r}-\\mathbf{x}_\\text{s}\\|}   in the case of the 3D acoustic Helmholtz equation.  Discrete case  The system of equations above can be straightforwardly discretized in the form   A_\\mathbf{m}\\mathbf{u} = \\mathbf{q},   where  A_\\mathbf{m}  is the system matrix representing the physics of the problem,  \\mathbf{u}  is the field vector (discretized  \\mathbf{P} ) and  \\mathbf{q}  is the  RHS  source vector (discretized  \\mathbf{S} ). The vector  \\mathbf{m}  represents discretized heterogenous model of velocity  \\mathbf{c} , upon which  A_\\mathbf{m}  is nonlinearly dependent. The task of solving system of equations for the field vector  \\mathbf{u}  requires inverting the matrix  A_\\mathbf{m} , such that  \\mathbf{u} = A_\\mathbf{m}^{-1}\\mathbf{q} .  Data synthesis  Once we are equipped with a scheme to form the system of equations  A_\\mathbf{m}  and invert it to solve for the field vector  \\mathbf{u} , we can go about the task of computing  synthetic data  to simulate the response of the field experiment. We describe a data restriction operator  \\mathcal{R}: \\mathscr{C}^3 \\to \\mathscr{C^1} , which maps from the complex 3D wavefield to the responses at a series of receiver locations. The action of this operator is a good conceptual model to understand how the observed data  \\mathbf{d}_\\text{obs}  arise from the field experiment. The equivalent matrix  R  extracts a 1D vector of synthetic data  \\mathbf{d}_\\text{syn}  from the field vector  \\mathbf{u} ,   \\mathbf{d}_\\text{syn} = R\\mathbf{u} = RA_\\mathbf{m}^{-1}\\mathbf{q}.", 
            "title": "Forward modelling"
        }, 
        {
            "location": "/background/#inversion", 
            "text": "In an ideal world, the synthetic data  \\mathbf{d}_\\text{syn}  would match the observed data  \\mathbf{d}_\\text{obs} . This perfect correspondence between the experimental results and the results of the computer model would indicate that the earth model  \\mathbf{m}  is correct (within the resolving ability of the experiment). 1  In order to quantify the errors in the model  \\mathbf{m} , we define an  objective function ,   \\phi\\left(\\mathbf{m}\\right) = \\frac{1}{2} \\|\\mathbf{d}_\\text{syn} - \\mathbf{d}_\\text{obs}\\|_2^2 = \\frac{1}{2} \\|R A_\\mathbf{m}^-1 \\mathbf{q} - \\mathbf{d}_\\text{obs}\\|_2^2,   which measures the error between the data arising from the field experiment ( \\mathbf{d}_\\text{obs} ) and the data arising from the numerical simulation ( \\mathbf{d}_\\text{syn} ) under the  L_2 -norm. Then, we define an inverse problem   \\mathbf{m}_\\text{opt} = \\underset{\\mathbf{m}}{\\operatorname{argmin}} \\phi\\left(\\mathbf{m}\\right),   with the purpose of finding the optimal model  \\mathbf{m}_\\text{opt} . If we were in possession of infinite computer resources, we could employ a global search over all feasible models  \\mathbf{m}_k  to find the best  \\phi_{\\mathbf{m}_k} = \\phi\\left(\\mathbf{m}_k\\right)  to fit the data 2 ; however, in practice the solution of the forward problem  \\mathbf{u} = A_\\mathbf{m}^{-1}\\mathbf{q}  is quite costly, and we must employ a more efficient method for finding (something close to)  \\mathbf{m}_\\text{opt} .  Local optimization  Rather than search over all possible  \\mathbf{m}_k , we can take advantage of the fact that we often have a good estimate of  \\mathbf{m}_\\text{opt}  to begin with. 3  In this case, we might consider implementing a  local optimization  method. The simplest example is the  steepest descent  or  gradient  algorigthm, which uses a first-order approximation to the rate of change of the data misfit with respect to each model parameter. The gradient is   \\nabla_{\\mathbf{m}_k} \\phi\\left(\\mathbf{m}\\right) = J_{\\mathbf{m}_k}^T\\delta\\mathbf{d}^* = J_{\\mathbf{m}_k}^T \\left[\\mathbf{d}_\\text{syn} - \\mathbf{d}_\\text{obs}\\right]^*,   where  J  is the Jacobian matrix of partial derivatives  J_{\\mathbf{m}_k;i,j} = \\frac{\\partial u_i}{\\partial m_j}  evaluated at the present model;  \\cdot^T  indicates transposition and  \\cdot^*  complex conjugation. The steepest descent algorithm is an iterative process, in which the model iterate  \\mathbf{m}_k  is updated in an attempt to go \"downhill\" in the space of the objective function  \\mathbf{\\phi} .   \\mathbf{m}_{k+1} = \\mathbf{m}_k - \\alpha_k \\nabla_{\\mathbf{m}_k} \\delta\\mathbf{d}^*   For appropriate choices of the scalar steplength  \\alpha  at each iteration,  \\mathbf{m}_k  will converge towards a model that finds a reduced value of  \\phi . 4  Various schemes exist to improve on the steepest descent algorithm, including projection methods, conjugate gradient approaches, and higher-order methods including Newton, Gauss-Newton and quasi-Newton (l-BFGS) schemes.  Model regularization  In the introduction to the  Inversion  section, we define the inverse problem that involves finding  \\mathbf{m}_\\text{opt}  to minimize the misfit function  \\phi\\left(m\\right) . However, we put no other  constraints  on the solution. In many practical cases, we know additional information about the sorts of models that can exist, or are most feasible. Therefore, it may make sense to solve a different problem, such as   \\mathbf{m}_\\text{opt} = \\underset{\\mathbf{m}}{\\operatorname{argmin}} \\phi\\left(\\mathbf{m}\\right) \\text{ subject to } \\mathbf{m} \\in \\mathcal{C},   which additionally requires that  \\mathbf{m}  sits inside some (convex) constraint set  \\mathcal{C} . This set could include all models that have velocities within a feasible range, or all models that are sufficiently smooth, etc. All of these criteria represent types of  model regularization .  In order to find models that fit this new problem, there are various approaches that may be used:   Projection methods  Define a projector  \\mathcal{P}  such that  \\text{range}\\left(\\mathcal{P}\\right) \\in \\mathcal{C} . 5  Then, the projector is applied to the candidate model terates to ensure that  \\mathbf{m}_k  continues to satisfy  \\mathcal{C} , e.g.,  \\mathbf{m}_{k+1} = \\mathcal{P} \\left[\\mathbf{m}_k - \\alpha_k \\nabla_{\\mathbf{m}_k} \\delta\\mathbf{d}^*\\right].   Penalty methods  Redefine the objective function  \\phi\\left(\\mathbf{m}\\right) = \\frac{1}{2} \\|R A_\\mathbf{m}^-1 \\mathbf{q} - \\mathbf{d}_\\text{obs}\\|_2^2 + \\frac{\\lambda_R}{2}\\|R\\mathbf{m}\\|_2^2 + \\frac{\\lambda_D}{2} \\|D\\left(\\mathbf{m}-\\mathbf{m}_\\text{ref}\\right)\\|_2^2,  with  R  and  D  chosen to penalize certain model properties. Typical choices might be for  R  to be a discrete representation of  \\nabla  (i.e., first spatial derivative) and  D  to be diagonal by construction.       Of course, in practice  \\mathbf{d}_\\text{obs} = \\mathcal{R}\\mathbf{P} + \\epsilon , where  \\epsilon  is some distribution of noise in the recordings, so a perfect match between  \\mathbf{d}_\\text{obs}  and  \\mathbf{d}_\\text{syn}  would be quite suspicious.    It is also important to point out that, in general, there is no single  \\mathbf{m}_\\text{opt}  with minimum misfit as measured under  \\phi_\\mathbf{m} . Rather, there are usually an infinite number of models that can give rise to a particular misfit  \\phi_{\\mathbf{m}_k} . This is an expression of nonuniqueness, and is one of the motivations for properly implementing  Model regularization .    In practice, this estimate typically comes from from another geophysical method (e.g., traveltime inversion), in combination with  a priori  knowledge of geology and rock physics information.    NB: This is true as long as the initial model iterate is not a stationary point, in which case  \\nabla_\\mathbf{m}  is zero.    A projector is a linear operator  \\mathcal{P}  that is  idempotent , meaning  \\mathcal{PP}\\mathbf{x} = \\mathcal{P}\\mathbf{x} .", 
            "title": "Inversion"
        }, 
        {
            "location": "/about/", 
            "text": "About\n\n\nZephyr\n is the product of research at the \nUniversity of Western Ontario\n, with funding through a \nNSERC\n Postdoctoral Fellowship to Brendan Smithyman and an \nNSERC\n Discovery Grant to R. Gerhard Pratt. In addition, \nZephyr\n interoperates tightly with \nSimPEG\n, a flexible tool for designing and executing geophysical inversion problems. In turn, both \nZephyr\n and \nSimPEG\n are dependent on the \nPython\n programming language, \nNumPy\n, \nSciPy\n and \nJupyter\n/\nIPython\n. Please check out and support these open-source projects.", 
            "title": "About"
        }, 
        {
            "location": "/about/#about", 
            "text": "Zephyr  is the product of research at the  University of Western Ontario , with funding through a  NSERC  Postdoctoral Fellowship to Brendan Smithyman and an  NSERC  Discovery Grant to R. Gerhard Pratt. In addition,  Zephyr  interoperates tightly with  SimPEG , a flexible tool for designing and executing geophysical inversion problems. In turn, both  Zephyr  and  SimPEG  are dependent on the  Python  programming language,  NumPy ,  SciPy  and  Jupyter / IPython . Please check out and support these open-source projects.", 
            "title": "About"
        }
    ]
}